transmute(
from = from,
to   = to,
relation_type = type
)
# Combine, drop bad edges, deduplicate
edges_all_viz <- bind_rows(edges_vert_viz, edges_horiz_viz) %>%
filter(!is.na(from), !is.na(to)) %>%             # <— key fix
distinct()
cat("Viz edges (clean):", nrow(edges_all_viz), "\n")
# 6.2 Build node table for visualization
all_ids <- sort(unique(c(edges_all_viz$from, edges_all_viz$to)))
nodes_all <- tibble(id = all_ids) %>%
# bring in labels/groups from the ancestry nodes table where available
left_join(
nodes %>%
transmute(id = node,
label = dplyr::coalesce(nodeLabel, node),
group_raw = group),
by = "id"
) %>%
mutate(
label   = coalesce(label, id),
is_seed = id %in% df$id_wikidata,
group   = case_when(
is_seed ~ "seed",
TRUE    ~ "person"
)
)
cat("Viz nodes:", nrow(nodes_all), "\n")
# 6.3 Build the master igraph object
g_all <- graph_from_data_frame(
d = edges_all_viz,
directed = TRUE,
vertices = nodes_all
)
cat("Master viz graph:",
vcount(g_all), "nodes |",
ecount(g_all), "edges\n")
# 6.4 Helper: pick a seed by QID or by label
pick_seed <- function(id_or_label) {
# If it looks like a QID, use it directly
if (startsWith(id_or_label, "Q")) {
if (!id_or_label %in% nodes_all$id) {
stop("QID not found in nodes_all: ", id_or_label)
}
return(id_or_label)
}
# Otherwise look up by label (exact match)
idx <- which(nodes_all$label == id_or_label)
if (length(idx) == 0) stop("No exact label match for: ", id_or_label)
if (length(idx) > 1) warning("Multiple label matches; taking the first.")
nodes_all$id[idx[1]]
}
# 6.5 Helper: create a visNetwork graph for one seed
# mode = "component": full connected component of that seed
# mode = "ego":       only nodes within 'order' steps of the seed
make_seed_vis <- function(seed_input,
mode = c("component", "ego"),
order = 3,
out_dir = "graphs/master_seeds") {
mode <- match.arg(mode)
dir_create(out_dir)
seed_id <- pick_seed(seed_input)
# Use an undirected view for connectivity (vertical + horizontal)
g_u <- as.undirected(g_all, mode = "collapse", edge.attr.comb = "first")
if (mode == "component") {
comp  <- components(g_u)$membership
seed_comp <- comp[match(seed_id, names(comp))]
keep_ids <- names(comp)[comp == seed_comp]
g_sub <- induced_subgraph(g_all, vids = keep_ids)
} else {
ego_nodes <- ego(g_u, order = order, nodes = seed_id)[[1]]
g_sub <- induced_subgraph(g_all, vids = ego_nodes)
}
vdf <- as_data_frame(g_sub, what = "vertices")
edf <- as_data_frame(g_sub, what = "edges")
# Nodes for visNetwork
nodes_vis <- data.frame(
id    = vdf$name,
label = vdf$label,
group = vdf$group,
title = paste0(
"<b>", vdf$label, "</b>",
"<br/>Q-ID: ", vdf$name,
"<br/>Seed: ", ifelse(vdf$is_seed, "yes", "no")
),
stringsAsFactors = FALSE
)
# Edges for visNetwork
edges_vis <- data.frame(
from   = edf$from,
to     = edf$to,
title  = edf$relation_type,
arrows = ifelse(edf$relation_type %in% c("has_father", "has_mother"),
"to", ""),
color  = dplyr::case_when(
edf$relation_type %in% c("has_father", "has_mother") ~ "#2c7fb8",  # vertical
edf$relation_type %in% c("spouse", "spouse_p26")     ~ "#1b9e77",  # spouses
grepl("^sibling", edf$relation_type)                 ~ "#7570b3",  # siblings
TRUE                                                 ~ "#aaaaaa"
),
width  = dplyr::case_when(
edf$relation_type %in% c("spouse", "spouse_p26") ~ 3,
grepl("^sibling", edf$relation_type)            ~ 2.5,
TRUE                                            ~ 1.5
),
smooth = TRUE,
stringsAsFactors = FALSE
)
vis <- visNetwork(nodes_vis, edges_vis, width = "100%", height = "720px") %>%
visOptions(
highlightNearest = TRUE,
nodesIdSelection = list(enabled = TRUE, useLabels = TRUE)
) %>%
visGroups(groupname = "seed",
color = list(background = "#00b3b3", border = "#008080")) %>%
visGroups(groupname = "person",
color = list(background = "#f0f0f0", border = "#bdbdbd")) %>%
visLegend(addEdges = data.frame(
label = c("Parent", "Spouse", "Sibling"),
color = c("#2c7fb8", "#1b9e77", "#7570b3")
)) %>%
visPhysics(stabilization = FALSE)
seed_label <- nodes_all$label[match(seed_id, nodes_all$id)]
fname <- sprintf("%s/%s_%s.html",
out_dir,
if (mode == "component") "component" else paste0("ego", order),
gsub("\\s+", "_", seed_label, perl = TRUE))
saveWidget(vis, file = fname, selfcontained = TRUE)
cat("Saved visualization for seed", seed_label, "→", fname, "\n")
invisible(fname)
}
#### 6.6 Global visualization: ALL seeds + ALL relationships ####
library(visNetwork)
library(htmlwidgets)
library(fs)
library(dplyr)
library(igraph)
dir_create("graphs/master_seeds")
# Get vertex and edge data from the global graph g_all
vdf_all <- igraph::as_data_frame(g_all, what = "vertices")
edf_all <- igraph::as_data_frame(g_all, what = "edges")
# Nodes for visNetwork (ALL people)
nodes_vis_all <- data.frame(
id    = vdf_all$name,
label = vdf_all$label,
group = vdf_all$group,
title = paste0(
"<b>", vdf_all$label, "</b>",
"<br/>Q-ID: ", vdf_all$name,
"<br/>Seed: ", ifelse(vdf_all$is_seed, "yes", "no")
),
stringsAsFactors = FALSE
)
# Edges for visNetwork (vertical + horizontal)
edges_vis_all <- data.frame(
from   = edf_all$from,
to     = edf_all$to,
title  = edf_all$relation_type,
arrows = ifelse(edf_all$relation_type %in% c("has_father", "has_mother"),
"to", ""),
color  = dplyr::case_when(
edf_all$relation_type %in% c("has_father", "has_mother") ~ "#2c7fb8",  # parents
edf_all$relation_type %in% c("spouse", "spouse_p26")     ~ "#1b9e77",  # spouses
grepl("^sibling", edf_all$relation_type)                 ~ "#7570b3",  # siblings
TRUE                                                     ~ "#aaaaaa"
),
width  = dplyr::case_when(
edf_all$relation_type %in% c("spouse", "spouse_p26") ~ 3,
grepl("^sibling", edf_all$relation_type)            ~ 2.5,
TRUE                                                ~ 1.5
),
smooth = TRUE,
stringsAsFactors = FALSE
)
# Build the big interactive graph
vis_all <- visNetwork(nodes_vis_all, edges_vis_all,
width = "100%", height = "800px") %>%
visOptions(
highlightNearest = TRUE,
nodesIdSelection = list(enabled = TRUE, useLabels = TRUE)
) %>%
visGroups(
groupname = "seed",
color = list(background = "#00b3b3", border = "#008080")
) %>%
visGroups(
groupname = "person",
color = list(background = "#f0f0f0", border = "#bdbdbd")
) %>%
visLegend(
addEdges = data.frame(
label = c("Parent", "Spouse", "Sibling"),
color = c("#2c7fb8", "#1b9e77", "#7570b3")
)
) %>%
visPhysics(
solver = "forceAtlas2Based",
stabilization = FALSE
)
out_file <- "graphs/master_seeds/all_seeds_full.html"
saveWidget(vis_all, file = out_file, selfcontained = TRUE)
cat("Saved global master graph →", out_file, "\n")
# pick_seed <- function(id_or_label) {
#   if (startsWith(id_or_label, "Q")) {
#     return(id_or_label)
#   } else {
#     idx <- match(id_or_label, V(graph)$nodeLabel)
#     if (is.na(idx)) stop("No exact nodeLabel match found for: ", id_or_label)
#     return(V(graph)$name[idx])
#   }
# }
#
# # Subgraph for a seed (descendants/ancestors reachable via edges)
# subgraph_for_seed <- function(seed_id) {
#   vids <- igraph::subcomponent(graph, v = seed_id, mode = "out")
#   igraph::induced_subgraph(graph, vids = vids)
# }
#
# # Distances/generation depth from the seed within a subgraph
# depth_from_seed <- function(g, seed_id) {
#   d <- igraph::distances(g, v = seed_id, mode = "out")
#   dv <- as.numeric(d[1, ])
#   names(dv) <- igraph::V(g)$name
#   dv
#}
# #### 4. Seed subgraph & generation depth ####
# SEED_INPUT <- "Jeff Bezos"
# seed_qid <- pick_seed(SEED_INPUT)
# cat("Chosen seed:", SEED_INPUT, "→ Q-ID:", seed_qid, "\n")
#
# g_sub <- subgraph_for_seed(seed_qid)
# cat("Subgraph size:", igraph::vcount(g_sub), "nodes |", igraph::ecount(g_sub), "edges\n")
#
# samp <- sample_horizontal_relatedness(edges, nodes, graph, seed_qid = seed_qid, n_each = 10)
# cat("\n--- SPOUSES (sample) ---\n"); print(samp$spouses)
# cat("\n--- SIBLINGS (sample) ---\n"); print(samp$siblings)
#
# cat("\n--- Spouses for seed ---\n"); print(get_spouses(seed_qid, edges, nodes))
# cat("\n--- Siblings (any) for seed ---\n"); print(get_siblings(seed_qid, edges, nodes, type = "any"))
#
# depth_vec <- depth_from_seed(g_sub, seed_qid)
# igraph::V(g_sub)$generation <- depth_vec[igraph::V(g_sub)$name]
# igraph::V(g_sub)$generation[!is.finite(igraph::V(g_sub)$generation)] <- NA
#
# # 4a. Export generation depth info
# library(fs); fs::dir_create("generated")
#
# g_sub_full <- g_sub
# all_qids <- igraph::V(g_sub_full)$name
# generation_seed <- tibble::tibble(
#   qid = all_qids,
#   generation_from_seed = {
#     dv <- depth_vec[qid]
#     ifelse(is.finite(dv), as.integer(dv), NA_integer_)
#   }
# )
#
# nodes_export <- igraph::as_data_frame(g_sub_full, what = "vertices") %>%
#   tibble::as_tibble() %>%
#   dplyr::rename(qid = name) %>%
#   dplyr::select(qid, dplyr::any_of(c("label", "title")))
#
# nodes_with_generation <- nodes_export %>%
#   dplyr::left_join(generation_seed, by = "qid")
#
# generation_summary <- nodes_with_generation %>%
#   dplyr::group_by(generation_from_seed) %>%
#   dplyr::summarise(n_nodes = dplyr::n(), .groups = "drop") %>%
#   dplyr::arrange(generation_from_seed)
#
# readr::write_csv(nodes_with_generation, "generated/nodes_generation_from_seed.csv")
# readr::write_csv(generation_summary,   "generated/generation_from_seed_summary.csv")
# cat("✔ Exported generation_from_seed data to /generated folder\n")
#
# # 4b. True ancestry depth (distance from roots)
# g_ig <- if (inherits(g_sub_full, "igraph")) g_sub_full else tidygraph::as.igraph(g_sub_full)
# roots <- which(igraph::degree(g_ig, mode = "in") == 0)
# dist_list <- lapply(roots, function(r) { igraph::distances(g_ig, v = r, to = igraph::V(g_ig), mode = "out") })
# dist_mat <- do.call(rbind, dist_list)
# depth_from_roots <- apply(dist_mat, 2, function(x) { if (all(is.infinite(x))) NA_integer_ else as.integer(min(x[is.finite(x)])) })
# names(depth_from_roots) <- colnames(dist_mat)
#
# nodes_with_generations <- nodes_with_generation %>%
#   dplyr::mutate(depth_from_roots = depth_from_roots[qid])
#
# readr::write_csv(nodes_with_generations, "generated/nodes_generation_with_ancestry_depth.csv")
# cat("✔ Exported nodes_generation_with_ancestry_depth.csv\n")
# #### 5. Optional: cap super-deep tails for plot ####
# MAX_GEN_SHOW <- 12
# keep <- which(is.na(igraph::V(g_sub)$generation) | igraph::V(g_sub)$generation <= MAX_GEN_SHOW)
# g_sub <- igraph::induced_subgraph(g_sub, vids = keep)
# cat("Plotted subgraph (capped at", MAX_GEN_SHOW, "generations):",
#     igraph::vcount(g_sub), "nodes |", igraph::ecount(g_sub), "edges\n")
# cat("Depth range (shown):",
#     min(igraph::V(g_sub)$generation, na.rm = TRUE), "to",
#     max(igraph::V(g_sub)$generation, na.rm = TRUE), "\n")
# #### 5. Visualizations Static ancestory plot (ggraph) ####
# dir.create("graphs", showWarnings = FALSE)
#
# viz_pkgs <- c("ggraph", "ggplot2", "tidygraph", "visNetwork", "htmlwidgets")
# lapply(viz_pkgs[!(viz_pkgs %in% installed.packages())], install.packages)
# lapply(viz_pkgs, library, character.only = TRUE)
#
# # 5a. Static hierarchy plot
# p <- ggraph(g_sub, layout = "sugiyama") +
#   geom_edge_link(aes(edge_colour = type), alpha = 0.6) +
#   geom_node_point(aes(color = group, size = ifelse(group == GROUP_LABEL, 4, 2))) +
#   geom_node_text(
#     aes(label = ifelse(group == GROUP_LABEL | generation <= 2, nodeLabel, "")),
#     repel = TRUE, size = 3
#   ) +
#   scale_edge_colour_manual(values = c(has_father = "#2c7fb8", has_mother = "#f768a1")) +
#   scale_size_identity() +
#   labs(
#     title = paste0("Ancestor tree (parents only) — seed: ",
#                    igraph::V(g_sub)$nodeLabel[igraph::V(g_sub)$name == seed_qid]),
#     subtitle = "Edges: child → parent (blue = father, pink = mother)"
#   ) +
#   theme_minimal()
#
# print(p)
# ggsave(filename = file.path("graphs", paste0("ancestors_", seed_qid, ".png")),
#        plot = p, width = 10, height = 7, dpi = 300)
# cat("Saved static plot → graphs/", paste0("ancestors_", seed_qid, ".png"), "\n", sep = "")
#
# # 5b. Interactive ancestery (visNetwork)
# library(visNetwork); library(htmlwidgets)
#
# nodes_df <- data.frame(
#   id    = igraph::V(g_sub)$name,
#   label = ifelse(is.na(igraph::V(g_sub)$nodeLabel) | igraph::V(g_sub)$nodeLabel=="",
#                  igraph::V(g_sub)$name, igraph::V(g_sub)$nodeLabel),
#   group = igraph::V(g_sub)$group,
#   level = as.integer(ifelse(is.finite(igraph::V(g_sub)$generation),
#                             igraph::V(g_sub)$generation, 0)),
#   title = paste0(
#     "<b>", igraph::V(g_sub)$nodeLabel, "</b>",
#     "<br/>Q-ID: ", igraph::V(g_sub)$name,
#     "<br/>Generation: ", igraph::V(g_sub)$generation
#   ),
#   stringsAsFactors = FALSE
# )
#
# e <- igraph::as_data_frame(g_sub, what = "edges")
# edges_df <- data.frame(
#   from   = e$from,
#   to     = e$to,
#   arrows = "to",
#   color  = ifelse(e$type == "has_father", "#2c7fb8", "#f768a1"),
#   title  = e$type,
#   smooth = FALSE,
#   stringsAsFactors = FALSE
# )
#
# vis <- visNetwork(nodes_df, edges_df, width = "100%", height = "720px") %>%
#   visHierarchicalLayout(direction = "UD",
#                         levelSeparation = 120,
#                         nodeSpacing = 180,
#                         treeSpacing = 180,
#                         sortMethod = "directed") %>%
#   visGroups(groupname = GROUP_LABEL,
#             color = list(background = "#00b3b3", border = "#008080")) %>%
#   visGroups(groupname = "ancestor",
#             color = list(background = "#f0f0f0", border = "#bdbdbd")) %>%
#   visOptions(highlightNearest = TRUE,
#              nodesIdSelection = list(enabled = TRUE, useLabels = TRUE)) %>%
#   visLegend() %>%
#   visEdges(width = 2) %>%
#   visPhysics(stabilization = FALSE)
#
# vis
#
# seed_label <- nodes_df$label[match(seed_qid, nodes_df$id)]
# out_html <- sprintf("graphs/ancestor_%s.html",
#                     gsub("\\s+", "_", seed_label, perl = TRUE))
# saveWidget(vis, file = out_html, selfcontained = TRUE)
#
# browseURL(out_html)
#
# #5c Visualizations, Interactive Horizontal relationships (visNetwork)
#
# # 0) Pull combined horizontal edges from the export result
# edges_h <- hr$edges_all
#
# # 1) Clean edges: drop NAs and non-Q IDs; de-duplicate
# edges_h <- edges_h %>%
#   dplyr::filter(!is.na(from), !is.na(to)) %>%
#   dplyr::filter(stringr::str_starts(from, "Q"), stringr::str_starts(to, "Q")) %>%
#   dplyr::select(from, to, type) %>%
#   dplyr::distinct()
#
# # 2) Build a vertex table that covers *all* endpoints in edges_h
# v_all <- sort(unique(c(edges_h$from, edges_h$to)))
#
# vdf <- tibble::tibble(name = v_all) %>%
#   dplyr::left_join(
#     nodes %>%
#       dplyr::transmute(name = node,
#                        label = dplyr::coalesce(nodeLabel, node),
#                        group = group),
#     by = "name"
#   ) %>%
#   dplyr::mutate(
#     label = dplyr::coalesce(label, name),
#     group = dplyr::coalesce(group, "ancestor")
#   )
#
# # 3) (Optional) sanity check: to check if anything is missing
# missing_ids <- setdiff(unique(c(edges_h$from, edges_h$to)), vdf$name)
# if (length(missing_ids)) {
#   cat("!! Missing in vdf (should be 0):", length(missing_ids), "\n")
#   print(head(missing_ids, 10))
# }
#
# # 4) Build undirected igraph safely
# hgraph <- igraph::graph_from_data_frame(edges_h, directed = FALSE, vertices = vdf)
#
# # 5) Focus on the seed’s connected component
# seed_qid_h <- pick_seed(SEED_INPUT)
# comp_h   <- igraph::components(hgraph)$membership
# seed_cc  <- comp_h[[seed_qid_h]]
# keep_ids <- names(comp_h)[comp_h == seed_cc]
# hsub     <- igraph::induced_subgraph(hgraph, vids = keep_ids)
#
# # 6) visNetwork nodes/edges
# hnodes <- data.frame(
#   id    = igraph::V(hsub)$name,
#   label = ifelse(is.na(igraph::V(hsub)$label) | igraph::V(hsub)$label=="",
#                  igraph::V(hsub)$name, igraph::V(hsub)$label),
#   group = igraph::V(hsub)$group,
#   stringsAsFactors = FALSE
# )
#
# he <- igraph::as_data_frame(hsub, what = "edges")
# hedges <- data.frame(
#   from  = he$from,
#   to    = he$to,
#   title = he$type,
#   color = dplyr::case_when(
#     he$type %in% c("spouse", "spouse_p26") ~ "#1b9e77",
#     grepl("^sibling", he$type)             ~ "#7570b3",
#     TRUE                                   ~ "#aaaaaa"
#   ),
#   width  = dplyr::case_when(
#     he$type %in% c("spouse", "spouse_p26") ~ 3,
#     TRUE                                   ~ 2
#   ),
#   smooth = TRUE,
#   stringsAsFactors = FALSE
# )
#
# # 7) Render + save
# vis_h <- visNetwork(hnodes, hedges, width = "100%", height = "720px") %>%
#   visOptions(highlightNearest = TRUE,
#              nodesIdSelection = list(enabled = TRUE, useLabels = TRUE)) %>%
#   visLegend(addEdges = data.frame(
#     label = c("Spouse (inferred/P26)", "Sibling (any)"),
#     color = c("#1b9e77", "#7570b3")
#   )) %>%
#   visGroups(groupname = GROUP_LABEL,
#             color = list(background = "#00b3b3", border = "#008080")) %>%
#   visGroups(groupname = "ancestor",
#             color = list(background = "#f0f0f0", border = "#bdbdbd")) %>%
#   visPhysics(stabilization = FALSE)
#
# vis_h
#
# dir.create("graphs", showWarnings = FALSE)
# seed_label_h <- hnodes$label[match(seed_qid_h, hnodes$id)]
# out_html_h <- sprintf("graphs/horizontal_%s.html",
#                       gsub("\\s+", "_", seed_label_h, perl = TRUE))
# htmlwidgets::saveWidget(vis_h, file = out_html_h, selfcontained = TRUE)
# browseURL(out_html_h)
# cat("Saved horizontal relationship graph → ", out_html_h, "\n", sep = "")
#
# ### The End ###
g_all
vdf_all
View(vdf_all)
vdf_all
vdf_all
# install.packages(c("sparklyr", "dplyr", "rvest", "stringr", "purrr"))
library(sparklyr)
install.packages(c("sparklyr", "dplyr", "rvest", "stringr", "purrr"))
install.packages(c("sparklyr", "dplyr", "rvest", "stringr", "purrr"))
library(sparklyr)
library(dplyr)
library(rvest)
library(stringr)
library(purrr)
sc <- spark_connect(master = "local")  # or your cluster master
library(sparklyr)
library(dplyr)
library(rvest)
library(stringr)
library(purrr)
sc <- spark_connect(master = "local")  # or your cluster master
spark_available_versions()
library(sparklyr)
library(dplyr)
sc <- spark_connect(
master  = "local",
version = "4.0.0"  # <-- use the same version you installed above
)
library(sparklyr)
library(dplyr)
sc <- spark_connect(
master  = "local",
version = "3.5.0"  # <-- use the same version you installed above
)
