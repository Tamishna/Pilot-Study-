visPhysics(
solver = "forceAtlas2Based",
stabilization = FALSE
)
out_file <- "graphs/master_seeds/all_seeds_full.html"
saveWidget(vis_all, file = out_file, selfcontained = TRUE)
cat("Saved global master graph →", out_file, "\n")
# pick_seed <- function(id_or_label) {
#   if (startsWith(id_or_label, "Q")) {
#     return(id_or_label)
#   } else {
#     idx <- match(id_or_label, V(graph)$nodeLabel)
#     if (is.na(idx)) stop("No exact nodeLabel match found for: ", id_or_label)
#     return(V(graph)$name[idx])
#   }
# }
#
# # Subgraph for a seed (descendants/ancestors reachable via edges)
# subgraph_for_seed <- function(seed_id) {
#   vids <- igraph::subcomponent(graph, v = seed_id, mode = "out")
#   igraph::induced_subgraph(graph, vids = vids)
# }
#
# # Distances/generation depth from the seed within a subgraph
# depth_from_seed <- function(g, seed_id) {
#   d <- igraph::distances(g, v = seed_id, mode = "out")
#   dv <- as.numeric(d[1, ])
#   names(dv) <- igraph::V(g)$name
#   dv
#}
# #### 4. Seed subgraph & generation depth ####
# SEED_INPUT <- "Jeff Bezos"
# seed_qid <- pick_seed(SEED_INPUT)
# cat("Chosen seed:", SEED_INPUT, "→ Q-ID:", seed_qid, "\n")
#
# g_sub <- subgraph_for_seed(seed_qid)
# cat("Subgraph size:", igraph::vcount(g_sub), "nodes |", igraph::ecount(g_sub), "edges\n")
#
# samp <- sample_horizontal_relatedness(edges, nodes, graph, seed_qid = seed_qid, n_each = 10)
# cat("\n--- SPOUSES (sample) ---\n"); print(samp$spouses)
# cat("\n--- SIBLINGS (sample) ---\n"); print(samp$siblings)
#
# cat("\n--- Spouses for seed ---\n"); print(get_spouses(seed_qid, edges, nodes))
# cat("\n--- Siblings (any) for seed ---\n"); print(get_siblings(seed_qid, edges, nodes, type = "any"))
#
# depth_vec <- depth_from_seed(g_sub, seed_qid)
# igraph::V(g_sub)$generation <- depth_vec[igraph::V(g_sub)$name]
# igraph::V(g_sub)$generation[!is.finite(igraph::V(g_sub)$generation)] <- NA
#
# # 4a. Export generation depth info
# library(fs); fs::dir_create("generated")
#
# g_sub_full <- g_sub
# all_qids <- igraph::V(g_sub_full)$name
# generation_seed <- tibble::tibble(
#   qid = all_qids,
#   generation_from_seed = {
#     dv <- depth_vec[qid]
#     ifelse(is.finite(dv), as.integer(dv), NA_integer_)
#   }
# )
#
# nodes_export <- igraph::as_data_frame(g_sub_full, what = "vertices") %>%
#   tibble::as_tibble() %>%
#   dplyr::rename(qid = name) %>%
#   dplyr::select(qid, dplyr::any_of(c("label", "title")))
#
# nodes_with_generation <- nodes_export %>%
#   dplyr::left_join(generation_seed, by = "qid")
#
# generation_summary <- nodes_with_generation %>%
#   dplyr::group_by(generation_from_seed) %>%
#   dplyr::summarise(n_nodes = dplyr::n(), .groups = "drop") %>%
#   dplyr::arrange(generation_from_seed)
#
# readr::write_csv(nodes_with_generation, "generated/nodes_generation_from_seed.csv")
# readr::write_csv(generation_summary,   "generated/generation_from_seed_summary.csv")
# cat("✔ Exported generation_from_seed data to /generated folder\n")
#
# # 4b. True ancestry depth (distance from roots)
# g_ig <- if (inherits(g_sub_full, "igraph")) g_sub_full else tidygraph::as.igraph(g_sub_full)
# roots <- which(igraph::degree(g_ig, mode = "in") == 0)
# dist_list <- lapply(roots, function(r) { igraph::distances(g_ig, v = r, to = igraph::V(g_ig), mode = "out") })
# dist_mat <- do.call(rbind, dist_list)
# depth_from_roots <- apply(dist_mat, 2, function(x) { if (all(is.infinite(x))) NA_integer_ else as.integer(min(x[is.finite(x)])) })
# names(depth_from_roots) <- colnames(dist_mat)
#
# nodes_with_generations <- nodes_with_generation %>%
#   dplyr::mutate(depth_from_roots = depth_from_roots[qid])
#
# readr::write_csv(nodes_with_generations, "generated/nodes_generation_with_ancestry_depth.csv")
# cat("✔ Exported nodes_generation_with_ancestry_depth.csv\n")
# #### 5. Optional: cap super-deep tails for plot ####
# MAX_GEN_SHOW <- 12
# keep <- which(is.na(igraph::V(g_sub)$generation) | igraph::V(g_sub)$generation <= MAX_GEN_SHOW)
# g_sub <- igraph::induced_subgraph(g_sub, vids = keep)
# cat("Plotted subgraph (capped at", MAX_GEN_SHOW, "generations):",
#     igraph::vcount(g_sub), "nodes |", igraph::ecount(g_sub), "edges\n")
# cat("Depth range (shown):",
#     min(igraph::V(g_sub)$generation, na.rm = TRUE), "to",
#     max(igraph::V(g_sub)$generation, na.rm = TRUE), "\n")
# #### 5. Visualizations Static ancestory plot (ggraph) ####
# dir.create("graphs", showWarnings = FALSE)
#
# viz_pkgs <- c("ggraph", "ggplot2", "tidygraph", "visNetwork", "htmlwidgets")
# lapply(viz_pkgs[!(viz_pkgs %in% installed.packages())], install.packages)
# lapply(viz_pkgs, library, character.only = TRUE)
#
# # 5a. Static hierarchy plot
# p <- ggraph(g_sub, layout = "sugiyama") +
#   geom_edge_link(aes(edge_colour = type), alpha = 0.6) +
#   geom_node_point(aes(color = group, size = ifelse(group == GROUP_LABEL, 4, 2))) +
#   geom_node_text(
#     aes(label = ifelse(group == GROUP_LABEL | generation <= 2, nodeLabel, "")),
#     repel = TRUE, size = 3
#   ) +
#   scale_edge_colour_manual(values = c(has_father = "#2c7fb8", has_mother = "#f768a1")) +
#   scale_size_identity() +
#   labs(
#     title = paste0("Ancestor tree (parents only) — seed: ",
#                    igraph::V(g_sub)$nodeLabel[igraph::V(g_sub)$name == seed_qid]),
#     subtitle = "Edges: child → parent (blue = father, pink = mother)"
#   ) +
#   theme_minimal()
#
# print(p)
# ggsave(filename = file.path("graphs", paste0("ancestors_", seed_qid, ".png")),
#        plot = p, width = 10, height = 7, dpi = 300)
# cat("Saved static plot → graphs/", paste0("ancestors_", seed_qid, ".png"), "\n", sep = "")
#
# # 5b. Interactive ancestery (visNetwork)
# library(visNetwork); library(htmlwidgets)
#
# nodes_df <- data.frame(
#   id    = igraph::V(g_sub)$name,
#   label = ifelse(is.na(igraph::V(g_sub)$nodeLabel) | igraph::V(g_sub)$nodeLabel=="",
#                  igraph::V(g_sub)$name, igraph::V(g_sub)$nodeLabel),
#   group = igraph::V(g_sub)$group,
#   level = as.integer(ifelse(is.finite(igraph::V(g_sub)$generation),
#                             igraph::V(g_sub)$generation, 0)),
#   title = paste0(
#     "<b>", igraph::V(g_sub)$nodeLabel, "</b>",
#     "<br/>Q-ID: ", igraph::V(g_sub)$name,
#     "<br/>Generation: ", igraph::V(g_sub)$generation
#   ),
#   stringsAsFactors = FALSE
# )
#
# e <- igraph::as_data_frame(g_sub, what = "edges")
# edges_df <- data.frame(
#   from   = e$from,
#   to     = e$to,
#   arrows = "to",
#   color  = ifelse(e$type == "has_father", "#2c7fb8", "#f768a1"),
#   title  = e$type,
#   smooth = FALSE,
#   stringsAsFactors = FALSE
# )
#
# vis <- visNetwork(nodes_df, edges_df, width = "100%", height = "720px") %>%
#   visHierarchicalLayout(direction = "UD",
#                         levelSeparation = 120,
#                         nodeSpacing = 180,
#                         treeSpacing = 180,
#                         sortMethod = "directed") %>%
#   visGroups(groupname = GROUP_LABEL,
#             color = list(background = "#00b3b3", border = "#008080")) %>%
#   visGroups(groupname = "ancestor",
#             color = list(background = "#f0f0f0", border = "#bdbdbd")) %>%
#   visOptions(highlightNearest = TRUE,
#              nodesIdSelection = list(enabled = TRUE, useLabels = TRUE)) %>%
#   visLegend() %>%
#   visEdges(width = 2) %>%
#   visPhysics(stabilization = FALSE)
#
# vis
#
# seed_label <- nodes_df$label[match(seed_qid, nodes_df$id)]
# out_html <- sprintf("graphs/ancestor_%s.html",
#                     gsub("\\s+", "_", seed_label, perl = TRUE))
# saveWidget(vis, file = out_html, selfcontained = TRUE)
#
# browseURL(out_html)
#
# #5c Visualizations, Interactive Horizontal relationships (visNetwork)
#
# # 0) Pull combined horizontal edges from the export result
# edges_h <- hr$edges_all
#
# # 1) Clean edges: drop NAs and non-Q IDs; de-duplicate
# edges_h <- edges_h %>%
#   dplyr::filter(!is.na(from), !is.na(to)) %>%
#   dplyr::filter(stringr::str_starts(from, "Q"), stringr::str_starts(to, "Q")) %>%
#   dplyr::select(from, to, type) %>%
#   dplyr::distinct()
#
# # 2) Build a vertex table that covers *all* endpoints in edges_h
# v_all <- sort(unique(c(edges_h$from, edges_h$to)))
#
# vdf <- tibble::tibble(name = v_all) %>%
#   dplyr::left_join(
#     nodes %>%
#       dplyr::transmute(name = node,
#                        label = dplyr::coalesce(nodeLabel, node),
#                        group = group),
#     by = "name"
#   ) %>%
#   dplyr::mutate(
#     label = dplyr::coalesce(label, name),
#     group = dplyr::coalesce(group, "ancestor")
#   )
#
# # 3) (Optional) sanity check: to check if anything is missing
# missing_ids <- setdiff(unique(c(edges_h$from, edges_h$to)), vdf$name)
# if (length(missing_ids)) {
#   cat("!! Missing in vdf (should be 0):", length(missing_ids), "\n")
#   print(head(missing_ids, 10))
# }
#
# # 4) Build undirected igraph safely
# hgraph <- igraph::graph_from_data_frame(edges_h, directed = FALSE, vertices = vdf)
#
# # 5) Focus on the seed’s connected component
# seed_qid_h <- pick_seed(SEED_INPUT)
# comp_h   <- igraph::components(hgraph)$membership
# seed_cc  <- comp_h[[seed_qid_h]]
# keep_ids <- names(comp_h)[comp_h == seed_cc]
# hsub     <- igraph::induced_subgraph(hgraph, vids = keep_ids)
#
# # 6) visNetwork nodes/edges
# hnodes <- data.frame(
#   id    = igraph::V(hsub)$name,
#   label = ifelse(is.na(igraph::V(hsub)$label) | igraph::V(hsub)$label=="",
#                  igraph::V(hsub)$name, igraph::V(hsub)$label),
#   group = igraph::V(hsub)$group,
#   stringsAsFactors = FALSE
# )
#
# he <- igraph::as_data_frame(hsub, what = "edges")
# hedges <- data.frame(
#   from  = he$from,
#   to    = he$to,
#   title = he$type,
#   color = dplyr::case_when(
#     he$type %in% c("spouse", "spouse_p26") ~ "#1b9e77",
#     grepl("^sibling", he$type)             ~ "#7570b3",
#     TRUE                                   ~ "#aaaaaa"
#   ),
#   width  = dplyr::case_when(
#     he$type %in% c("spouse", "spouse_p26") ~ 3,
#     TRUE                                   ~ 2
#   ),
#   smooth = TRUE,
#   stringsAsFactors = FALSE
# )
#
# # 7) Render + save
# vis_h <- visNetwork(hnodes, hedges, width = "100%", height = "720px") %>%
#   visOptions(highlightNearest = TRUE,
#              nodesIdSelection = list(enabled = TRUE, useLabels = TRUE)) %>%
#   visLegend(addEdges = data.frame(
#     label = c("Spouse (inferred/P26)", "Sibling (any)"),
#     color = c("#1b9e77", "#7570b3")
#   )) %>%
#   visGroups(groupname = GROUP_LABEL,
#             color = list(background = "#00b3b3", border = "#008080")) %>%
#   visGroups(groupname = "ancestor",
#             color = list(background = "#f0f0f0", border = "#bdbdbd")) %>%
#   visPhysics(stabilization = FALSE)
#
# vis_h
#
# dir.create("graphs", showWarnings = FALSE)
# seed_label_h <- hnodes$label[match(seed_qid_h, hnodes$id)]
# out_html_h <- sprintf("graphs/horizontal_%s.html",
#                       gsub("\\s+", "_", seed_label_h, perl = TRUE))
# htmlwidgets::saveWidget(vis_h, file = out_html_h, selfcontained = TRUE)
# browseURL(out_html_h)
# cat("Saved horizontal relationship graph → ", out_html_h, "\n", sep = "")
#
# ### The End ###
#### 7. Extended kinship: uncles/aunts + cousins for each seed ####
#### 7. Extended kinship (uncles/aunts, cousins, etc.) ####
library(dplyr)
library(purrr)
library(tidyr)
library(readr)
# Vertical parent–child edges: child -> parent
vert_edges_core <- edges %>%
filter(type %in% c("has_father", "has_mother")) %>%
transmute(
child       = from,
parent      = to,
parent_type = type
)
# All sibling edges (inferred + P3373)
sib_edges_core <- hr$edges_all %>%
filter(grepl("^sibling", type)) %>%
transmute(
from,
to,
sibling_type = type
)
#name lookup
name_map <- nodes %>%
transmute(
qid  = node,
name = coalesce(nodeLabel, node)
)
get_parents <- function(qid) {
vert_edges_core %>%
filter(child == qid) %>%
transmute(
parent_qid  = parent,
parent_role = if_else(parent_type == "has_father", "father", "mother")
) %>%
distinct()
}
get_children <- function(qid) {
vert_edges_core %>%
filter(parent == qid) %>%
transmute(
child_qid   = child,
parent_qid  = parent,
parent_role = if_else(parent_type == "has_father", "father", "mother")
) %>%
distinct()
}
get_siblings_any <- function(qid) {
sib_long <- bind_rows(
sib_edges_core %>% transmute(ego = from, alter = to, sibling_type),
sib_edges_core %>% transmute(ego = to,   alter = from, sibling_type)
)
sib_long %>%
filter(ego == qid, !is.na(alter)) %>%
transmute(
ego_qid     = ego,
sibling_qid = alter,
sibling_type
) %>%
distinct()
}
inspect_seed_family <- function(seed_qid) {
seed_name <- name_map$name[match(seed_qid, name_map$qid)]
## 7.1) Siblings + children of seed
sibs <- get_siblings_any(seed_qid) %>%
left_join(name_map, by = c("sibling_qid" = "qid")) %>%
rename(sibling_name = name) %>%
mutate(
seed_qid  = seed_qid,
seed_name = seed_name,
.before   = 1
)
kids <- get_children(seed_qid) %>%
left_join(name_map, by = c("child_qid" = "qid")) %>%
rename(child_name = name) %>%
mutate(
seed_qid  = seed_qid,
seed_name = seed_name,
.before   = 1
)
## 7.2) Seed’s siblings’ children (nieces/nephews of seed)
nieces_nephews <- tibble()
if (nrow(sibs) > 0) {
nieces_nephews <- sibs %>%
select(seed_qid, seed_name, sibling_qid, sibling_name) %>%
left_join(
vert_edges_core %>%
transmute(
parent_qid = parent,
child_qid  = child,
parent_type
),
by = c("sibling_qid" = "parent_qid")
) %>%
filter(!is.na(child_qid)) %>%
left_join(name_map, by = c("child_qid" = "qid")) %>%
rename(niece_nephew_name = name) %>%
mutate(
relationship = case_when(
parent_type == "has_father" ~ "niece_nephew_through_paternal_sibling",
parent_type == "has_mother" ~ "niece_nephew_through_maternal_sibling",
TRUE                        ~ "niece_nephew"
)
) %>%
select(seed_qid, seed_name,
sibling_qid, sibling_name,
child_qid, niece_nephew_name,
relationship)
}
## 7.3) Seed’s children & their uncles/aunts (seed’s siblings)
uncles_of_kids <- tibble()
if (nrow(sibs) > 0 && nrow(kids) > 0) {
uncles_of_kids <- kids %>%
select(seed_qid, seed_name,
child_qid, child_name, parent_role) %>%
tidyr::crossing(
sibs %>% select(sibling_qid, sibling_name)
) %>%
mutate(
relationship = case_when(
parent_role == "father" ~ "paternal_uncle_aunt_of_child",
parent_role == "mother" ~ "maternal_uncle_aunt_of_child",
TRUE                    ~ "uncle_aunt_of_child"
)
)
}
## 7.4) Seed’s parents, their siblings (uncles/aunts) & their children
parents <- get_parents(seed_qid) %>%
left_join(name_map, by = c("parent_qid" = "qid")) %>%
rename(parent_name = name)
ua <- tibble()
if (nrow(parents) > 0) {
ua_list <- lapply(seq_len(nrow(parents)), function(i) {
p_qid  <- parents$parent_qid[i]
p_role <- parents$parent_role[i]
sib_p <- get_siblings_any(p_qid)
if (nrow(sib_p) == 0) return(NULL)
sib_p %>%
transmute(
seed_qid       = seed_qid,
parent_qid     = p_qid,
parent_role    = p_role,
uncle_aunt_qid = sibling_qid,
sibling_type   = sibling_type
)
})
ua_list <- Filter(Negate(is.null), ua_list)
if (length(ua_list) > 0) {
ua <- bind_rows(ua_list) %>%
left_join(name_map, by = c("uncle_aunt_qid" = "qid")) %>%
rename(uncle_aunt_name = name) %>%
left_join(name_map, by = c("parent_qid" = "qid")) %>%
rename(parent_name = name) %>%
mutate(
seed_name = seed_name,
relationship = case_when(
parent_role == "father" ~ "paternal_uncle_aunt",
parent_role == "mother" ~ "maternal_uncle_aunt",
TRUE                    ~ "uncle_aunt"
),
.before = 1
)
}
}
cousins <- tibble()
if (nrow(ua) > 0) {
cousins <- ua %>%
select(seed_qid, seed_name,
parent_qid, parent_name, parent_role,
uncle_aunt_qid, uncle_aunt_name, sibling_type) %>%
left_join(
vert_edges_core %>%
transmute(
uncle_aunt_qid = parent,
cousin_qid     = child,
parent_type
),
by = "uncle_aunt_qid"
) %>%
filter(!is.na(cousin_qid)) %>%
left_join(name_map, by = c("cousin_qid" = "qid")) %>%
rename(cousin_name = name) %>%
mutate(
relationship = case_when(
parent_role == "father" ~ "paternal_first_cousin",
parent_role == "mother" ~ "maternal_first_cousin",
TRUE                    ~ "first_cousin"
)
)
}
list(
siblings       = sibs,
children       = kids,
nieces_nephews = nieces_nephews,
uncles_of_kids = uncles_of_kids,
uncles_aunts   = ua,
cousins        = cousins
)
}
# Use the limited seed set, not all df$id_wikidata
all_seeds <- seeds
cat("Computing local family for", length(all_seeds), "seeds...\n")
kin_list <- lapply(all_seeds, inspect_seed_family)
# Combine across seeds for each relationship type
siblings_all       <- bind_rows(lapply(kin_list, `[[`, "siblings"))
children_all       <- bind_rows(lapply(kin_list, `[[`, "children"))
nieces_nephews_all <- bind_rows(lapply(kin_list, `[[`, "nieces_nephews"))
uncles_of_kids_all <- bind_rows(lapply(kin_list, `[[`, "uncles_of_kids"))
uncles_aunts_all   <- bind_rows(lapply(kin_list, `[[`, "uncles_aunts"))
cousins_all        <- bind_rows(lapply(kin_list, `[[`, "cousins"))
dir.create("generated/extended_kin", showWarnings = FALSE, recursive = TRUE)
write_csv(siblings_all,       "generated/extended_kin/siblings_all_seeds.csv")
write_csv(children_all,       "generated/extended_kin/children_all_seeds.csv")
write_csv(nieces_nephews_all, "generated/extended_kin/nieces_nephews_all_seeds.csv")
write_csv(uncles_of_kids_all, "generated/extended_kin/uncles_of_kids_all_seeds.csv")
write_csv(uncles_aunts_all,   "generated/extended_kin/uncles_aunts_all_seeds.csv")
write_csv(cousins_all,        "generated/extended_kin/cousins_all_seeds.csv")
cat("✔ Saved extended kinship CSVs for all seeds in SEED_LIMIT to generated/extended_kin/\n")
##End of timer
global_end <- Sys.time()
total_time <- as.numeric(global_end - global_start, units = "secs")
avg_time   <- total_time / length(seeds)
cat("\n===== OVERALL SEED PIPELINE TIMING =====\n")
cat("Seeds used in ancestry (SEED_LIMIT):", length(seeds), "\n")
cat("Total time (ancestors + spouses/siblings + kinship):",
round(total_time, 2), "seconds\n")
cat("Average time per seed:",
round(avg_time, 3), "seconds\n")
cat("Estimated time for 200 seeds:",
round(avg_time * 200, 1), "seconds (",
round(avg_time * 200 / 60, 2), "minutes )\n")
