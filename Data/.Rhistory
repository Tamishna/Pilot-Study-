"  SERVICE wikibase:label { bd:serviceParam wikibase:language 'de,en'. } ",
"}"
)
Sys.sleep(BASE_SLEEP)
res <- safe_query(sparql)
res <- res %>% dplyr::mutate(dplyr::across(dplyr::everything(), as.character))
if (nrow(res) == 0) {
res <- tibble::tibble(
item = qid, itemLabel = NA_character_,
father = NA_character_, fatherLabel = NA_character_,
mother = NA_character_, motherLabel = NA_character_,
item_birth_year = NA_character_, item_death_year = NA_character_,
father_birth_year = NA_character_, father_death_year = NA_character_,
mother_birth_year = NA_character_, mother_death_year = NA_character_
)
}
saveRDS(res, cf)
res
}
#### 2c. Ancestor traversal (BFS over parents) ####
ancestors_for_seed <- function(seed_qid, max_depth = MAX_DEPTH) {
visited <- new.env(hash = TRUE, parent = emptyenv())
labels  <- list()
set_label <- function(qid, lbl) { if (isTRUE(nchar(lbl) > 0)) labels[[qid]] <<- lbl }
edge_buf <- list()
frontier <- data.frame(qid = seed_qid, depth = 0, stringsAsFactors = FALSE)
visited[[seed_qid]] <- TRUE
total_edges <- 0L
while (nrow(frontier) > 0) {
this_depth <- frontier$depth[1]
if (this_depth >= max_depth) break
next_frontier <- list()
for (i in seq_len(nrow(frontier))) {
child_qid <- frontier$qid[i]
d         <- frontier$depth[i]
info <- wd_get_parents(child_qid)
set_label(child_qid, info$itemLabel[1])
if (!is.na(info$father[1]) && stringr::str_starts(info$father[1], "Q")) {
father_qid <- info$father[1]
set_label(father_qid, info$fatherLabel[1])
edge_buf[[length(edge_buf) + 1]] <- tibble::tibble(
from = child_qid, to = father_qid, type = "has_father",
fromLabel = info$itemLabel[1], toLabel = info$fatherLabel[1]
)
total_edges <- total_edges + 1L
if (is.null(visited[[father_qid]])) {
visited[[father_qid]] <- TRUE
next_frontier[[length(next_frontier) + 1]] <- data.frame(
qid = father_qid, depth = d + 1, stringsAsFactors = FALSE
)
}
}
if (!is.na(info$mother[1]) && stringr::str_starts(info$mother[1], "Q")) {
mother_qid <- info$mother[1]
set_label(mother_qid, info$motherLabel[1])
edge_buf[[length(edge_buf) + 1]] <- tibble::tibble(
from = child_qid, to = mother_qid, type = "has_mother",
fromLabel = info$itemLabel[1], toLabel = info$motherLabel[1]
)
total_edges <- total_edges + 1L
if (is.null(visited[[mother_qid]])) {
visited[[mother_qid]] <- TRUE
next_frontier[[length(next_frontier) + 1]] <- data.frame(
qid = mother_qid, depth = d + 1, stringsAsFactors = FALSE
)
}
}
}
if (length(next_frontier) > 0) {
frontier <- do.call(rbind, next_frontier)
} else {
frontier <- frontier[0, , drop = FALSE]
}
cat(sprintf("  depth %d → next frontier: %d nodes | edges so far: %d\n",
this_depth + 1, nrow(frontier), total_edges))
}
edges <- if (length(edge_buf) > 0) dplyr::bind_rows(edge_buf) else
tibble::tibble(from = character(), to = character(),
type = character(), fromLabel = character(), toLabel = character())
edges <- unique(edges)
node_ids <- unique(c(edges$from, edges$to))
`%||%` <- function(x, y) if (is.null(x) || length(x) == 0L || is.na(x)) y else x
node_labels <- vapply(node_ids, function(q) labels[[q]] %||% NA_character_, FUN.VALUE = character(1))
nodes <- tibble::tibble(
node = node_ids,
nodeLabel = node_labels
)
list(edges = edges, nodes = nodes)
}
`%||%` <- function(x, y) if (is.null(x) || length(x) == 0L || is.na(x)) y else x
#### 2d. Merge seeds, dedupe, augment with children ####
all_edges <- list()
all_nodes <- list()
cat(sprintf("Running parent-only ancestry on %d seed(s)\n", length(seeds)))
for (si in seq_along(seeds)) {
seed <- seeds[[si]]
cat(sprintf("[%d/%d] seed = %s\n", si, length(seeds), seed))
res <- tryCatch(
{ ancestors_for_seed(seed, max_depth = MAX_DEPTH) },
error = function(e) {
message("  !! Error on seed ", seed, ": ", conditionMessage(e))
return(NULL)
}
)
if (!is.null(res)) {
all_edges[[length(all_edges) + 1]] <- res$edges
res$nodes$is_seed <- res$nodes$node %in% seed
all_nodes[[length(all_nodes) + 1]] <- res$nodes
}
}
edges <- if (length(all_edges) > 0) dplyr::bind_rows(all_edges) else
tibble::tibble(from = character(), to = character(),
type = character(), fromLabel = character(), toLabel = character())
nodes <- if (length(all_nodes) > 0) dplyr::bind_rows(all_nodes) else
tibble::tibble(node = character(), nodeLabel = character(), is_seed = logical())
# Deduplicate
edges <- unique(edges)
nodes <- nodes %>%
dplyr::group_by(node) %>%
dplyr::summarize(
nodeLabel = dplyr::coalesce(dplyr::first(na.omit(nodeLabel)), NA_character_),
is_seed = any(is_seed, na.rm = TRUE),
.groups = "drop"
)
# Use neutral group label
GROUP_LABEL <- "seed list"
nodes <- nodes %>%
dplyr::mutate(
group = ifelse(is_seed | node %in% df$id_wikidata, GROUP_LABEL, "ancestor"),
id = dplyr::row_number() - 1L,
nodeLabel2 = paste(nodeLabel, id)
)
# Minimal weights
edges$value <- 1L
# Remove duplicate edges by (from, to, type)
edges <- edges %>% dplyr::distinct(from, to, type, .keep_all = TRUE)
#### 3. Horizontal relationships (spouse/sibling) ####
cat("----\n")
cat(sprintf("Before augmentation → Nodes: %s | Edges: %s\n", nrow(nodes), nrow(edges)))
# Add child edges (downward) to enrich horizontal inference
aug <- augment_graph_with_children(edges, nodes)
edges <- aug$edges
nodes <- nodes %>%
dplyr::full_join(aug$nodes, by = "node", suffix = c("", ".new")) %>%
dplyr::mutate(nodeLabel = dplyr::coalesce(nodeLabel, nodeLabel.new)) %>%
dplyr::select(-nodeLabel.new)
edges <- edges %>%
# parent labels
dplyr::left_join(
nodes %>% dplyr::transmute(to = node, toLabel_fill = dplyr::coalesce(nodeLabel, node)),
by = "to"
) %>%
# child labels
dplyr::left_join(
nodes %>% dplyr::transmute(from = node, fromLabel_fill = dplyr::coalesce(nodeLabel, node)),
by = "from"
) %>%
dplyr::mutate(
toLabel   = dplyr::coalesce(toLabel, toLabel_fill, to),
fromLabel = dplyr::coalesce(fromLabel, fromLabel_fill, from),
value     = dplyr::coalesce(value, 1L)
) %>%
dplyr::select(-toLabel_fill, -fromLabel_fill)
cat(sprintf("After augmentation → Nodes: %s | Edges: %s\n", nrow(nodes), nrow(edges)))
# Quick CSVs
readr::write_csv(nodes, "data_prepared/anc_nodes.csv")
readr::write_csv(edges, "data_prepared/anc_edges.csv")
# Graph
graph <- igraph::graph_from_data_frame(edges, directed = TRUE, vertices = nodes)
cat(sprintf("Final graph → %s nodes | %s edges\n", igraph::vcount(graph), igraph::ecount(graph)))
save(graph, nodes, edges, file = "data_prepared/seedlist_ancestors_only.RData")
cat("Saved:\n  - data_prepared/seedlist_ancestors_only.RData\n",
"  - data_prepared/anc_nodes.csv\n",
"  - data_prepared/anc_edges.csv\n")
#Export horoizontal relationships to CSVs
hr <- export_horizontal_relationships(
edges, nodes,
out_dir = "generated",
refresh_direct = FALSE   # set TRUE once to ignore caches, then back to FALSE
)
cat("Files in generated/: ", paste(list.files("generated"), collapse = ", "), "\n")
###NEW
#### X. Compute generation + depth for ALL seeds ####
library(dplyr)
library(igraph)
library(purrr)
library(tidyr)
# All seeds from your seed spreadsheet
all_seeds <- df$id_wikidata
cat("Computing generation/depth for", length(all_seeds), "seeds...\n")
gen_table_list <- list()
for (seed in all_seeds) {
if (!seed %in% V(graph)$name) {
cat("Skipping seed not in graph:", seed, "\n")
next
}
vids <- igraph::subcomponent(graph, v = seed, mode = "out")
g_sub <- induced_subgraph(graph, vids)
dmat <- igraph::distances(g_sub, v = seed, mode = "out")[1, ]
dmat <- ifelse(is.infinite(dmat), NA, dmat)
gen_table_list[[seed]] <- tibble(
qid = names(dmat),
!!paste0("gen_from_", seed) := dmat
)
}
gen_all <- reduce(gen_table_list, full_join, by = "qid")
# Depth-from-roots computation (global, independent of seed)
roots <- which(igraph::degree(graph, mode = "in") == 0)
dist_list <- lapply(roots, function(r) igraph::distances(graph, v = r, mode = "out")[1, ])
dist_matrix <- do.call(rbind, dist_list)
depth_vec <- apply(dist_matrix, 2, function(x) {
if (all(is.infinite(x))) NA_integer_ else min(x[is.finite(x)])
})
gen_all$depth_from_roots <- depth_vec[match(gen_all$qid, names(depth_vec))]
# Save
readr::write_csv(gen_all, "generated/nodes_generation_all_seeds.csv")
cat("✔ Saved generation/depth for ALL seeds → generated/nodes_generation_all_seeds.csv\n")
###NEW2
#### 6. Master relationship CSV (vertical + horizontal) ####
library(dplyr)
library(tidyr)
library(readr)
# Load seed-generation table
gen_all <- readr::read_csv("generated/nodes_generation_all_seeds.csv",
show_col_types = FALSE)
# Names fallback table
name_map <- nodes %>%
transmute(qid = node,
name = dplyr::coalesce(nodeLabel, node))
# Add names from horizontal counts if available
if (file.exists("generated/horizontal_counts_per_person.csv")) {
horiz_counts <- readr::read_csv("generated/horizontal_counts_per_person.csv",
show_col_types = FALSE)
name_map2 <- horiz_counts %>% select(qid, name)
name_map <- bind_rows(name_map, name_map2) %>%
group_by(qid) %>% summarise(name = first(na.omit(name)), .groups = "drop")
}
# Vertical edges (ancestry)
vert_edges <- edges %>%
filter(type %in% c("has_father", "has_mother")) %>%
transmute(
src_qid       = from,
dst_qid       = to,
relation_type = type,
source_file   = "anc_edges"
)
# Horizontal edges
horiz_edges <- hr$edges_all %>%
transmute(
src_qid       = from,
dst_qid       = to,
relation_type = type,
source_file   = "horizontal_edges_all_sources"
)
master_edges <- bind_rows(vert_edges, horiz_edges) %>%
distinct()
# Attach names
master_with_names <- master_edges %>%
left_join(name_map %>% rename(src_qid = qid, src_name = name),
by = "src_qid") %>%
left_join(name_map %>% rename(dst_qid = qid, dst_name = name),
by = "dst_qid")
# Attach all-seed generation info
gen_long <- gen_all %>%
pivot_longer(
starts_with("gen_from_"),
names_to = "seed_id",
values_to = "generation_from_seed"
)
master_full <- master_with_names %>%
left_join(gen_long %>% rename(src_qid = qid,
src_generation_from_seed = generation_from_seed),
by = "src_qid") %>%
left_join(gen_long %>% rename(dst_qid = qid,
dst_generation_from_seed = generation_from_seed),
by = c("dst_qid", "seed_id")) %>%
# depth-from-roots
left_join(gen_all %>% select(qid, depth_from_roots) %>%
rename(src_qid = qid, src_depth_from_roots = depth_from_roots),
by = "src_qid") %>%
left_join(gen_all %>% select(qid, depth_from_roots) %>%
rename(dst_qid = qid, dst_depth_from_roots = depth_from_roots),
by = "dst_qid")
readr::write_csv(master_full, "generated/master_relationships_full.csv")
cat("✔ Wrote multi-seed master CSV to: generated/master_relationships_full.csv\n")
# Quick sanity check in R:
print(master_full %>% count(relation_type))
###Master CSV Visualization:
#### 7. Visualizations: vertical + horizontal for all seeds ####
library(dplyr)
library(igraph)
library(visNetwork)
library(htmlwidgets)
library(fs)
# 7.1 Build a combined edge list for visualization -----------------------
# Vertical edges (parents)
edges_vert_viz <- edges %>%
filter(type %in% c("has_father", "has_mother")) %>%
transmute(
from = from,
to   = to,
relation_type = type
)
# Horizontal edges (spouses + siblings)
edges_horiz_viz <- hr$edges_all %>%
transmute(
from = from,
to   = to,
relation_type = type
)
# Combine, drop bad edges, deduplicate
edges_all_viz <- bind_rows(edges_vert_viz, edges_horiz_viz) %>%
filter(!is.na(from), !is.na(to)) %>%             # <— key fix
distinct()
cat("Viz edges (clean):", nrow(edges_all_viz), "\n")
# 7.2 Build node table for visualization ---------------------------------
all_ids <- sort(unique(c(edges_all_viz$from, edges_all_viz$to)))
nodes_all <- tibble(id = all_ids) %>%
# bring in labels/groups from the ancestry nodes table where available
left_join(
nodes %>%
transmute(id = node,
label = dplyr::coalesce(nodeLabel, node),
group_raw = group),
by = "id"
) %>%
mutate(
label   = coalesce(label, id),
is_seed = id %in% df$id_wikidata,
group   = case_when(
is_seed ~ "seed",
TRUE    ~ "person"
)
)
cat("Viz nodes:", nrow(nodes_all), "\n")
# 7.3 Build the master igraph object -------------------------------------
g_all <- graph_from_data_frame(
d = edges_all_viz,
directed = TRUE,
vertices = nodes_all
)
cat("Master viz graph:",
vcount(g_all), "nodes |",
ecount(g_all), "edges\n")
# 7.4 Helper: pick a seed by QID or by label -----------------------------
pick_seed <- function(id_or_label) {
# If it looks like a QID, use it directly
if (startsWith(id_or_label, "Q")) {
if (!id_or_label %in% nodes_all$id) {
stop("QID not found in nodes_all: ", id_or_label)
}
return(id_or_label)
}
# Otherwise look up by label (exact match)
idx <- which(nodes_all$label == id_or_label)
if (length(idx) == 0) stop("No exact label match for: ", id_or_label)
if (length(idx) > 1) warning("Multiple label matches; taking the first.")
nodes_all$id[idx[1]]
}
# 7.5 Helper: create a visNetwork graph for one seed ---------------------
# mode = "component": full connected component of that seed
# mode = "ego":       only nodes within 'order' steps of the seed
make_seed_vis <- function(seed_input,
mode = c("component", "ego"),
order = 3,
out_dir = "graphs/master_seeds") {
mode <- match.arg(mode)
dir_create(out_dir)
seed_id <- pick_seed(seed_input)
# Use an undirected view for connectivity (vertical + horizontal)
g_u <- as.undirected(g_all, mode = "collapse", edge.attr.comb = "first")
if (mode == "component") {
comp  <- components(g_u)$membership
seed_comp <- comp[match(seed_id, names(comp))]
keep_ids <- names(comp)[comp == seed_comp]
g_sub <- induced_subgraph(g_all, vids = keep_ids)
} else {
ego_nodes <- ego(g_u, order = order, nodes = seed_id)[[1]]
g_sub <- induced_subgraph(g_all, vids = ego_nodes)
}
vdf <- as_data_frame(g_sub, what = "vertices")
edf <- as_data_frame(g_sub, what = "edges")
# Nodes for visNetwork
nodes_vis <- data.frame(
id    = vdf$name,
label = vdf$label,
group = vdf$group,
title = paste0(
"<b>", vdf$label, "</b>",
"<br/>Q-ID: ", vdf$name,
"<br/>Seed: ", ifelse(vdf$is_seed, "yes", "no")
),
stringsAsFactors = FALSE
)
# Edges for visNetwork
edges_vis <- data.frame(
from   = edf$from,
to     = edf$to,
title  = edf$relation_type,
arrows = ifelse(edf$relation_type %in% c("has_father", "has_mother"),
"to", ""),
color  = dplyr::case_when(
edf$relation_type %in% c("has_father", "has_mother") ~ "#2c7fb8",  # vertical
edf$relation_type %in% c("spouse", "spouse_p26")     ~ "#1b9e77",  # spouses
grepl("^sibling", edf$relation_type)                 ~ "#7570b3",  # siblings
TRUE                                                 ~ "#aaaaaa"
),
width  = dplyr::case_when(
edf$relation_type %in% c("spouse", "spouse_p26") ~ 3,
grepl("^sibling", edf$relation_type)            ~ 2.5,
TRUE                                            ~ 1.5
),
smooth = TRUE,
stringsAsFactors = FALSE
)
vis <- visNetwork(nodes_vis, edges_vis, width = "100%", height = "720px") %>%
visOptions(
highlightNearest = TRUE,
nodesIdSelection = list(enabled = TRUE, useLabels = TRUE)
) %>%
visGroups(groupname = "seed",
color = list(background = "#00b3b3", border = "#008080")) %>%
visGroups(groupname = "person",
color = list(background = "#f0f0f0", border = "#bdbdbd")) %>%
visLegend(addEdges = data.frame(
label = c("Parent", "Spouse", "Sibling"),
color = c("#2c7fb8", "#1b9e77", "#7570b3")
)) %>%
visPhysics(stabilization = FALSE)
seed_label <- nodes_all$label[match(seed_id, nodes_all$id)]
fname <- sprintf("%s/%s_%s.html",
out_dir,
if (mode == "component") "component" else paste0("ego", order),
gsub("\\s+", "_", seed_label, perl = TRUE))
saveWidget(vis, file = fname, selfcontained = TRUE)
cat("Saved visualization for seed", seed_label, "→", fname, "\n")
invisible(fname)
}
make_seed_vis("Jeff Bezos", mode = "ego", order = 3)
make_seed_vis("Jeff Bezos", mode = "ego", order = 3)
#### 7.6 Global visualization: ALL seeds + ALL relationships ####
library(visNetwork)
library(htmlwidgets)
library(fs)
library(dplyr)
library(igraph)
# Make sure output folder exists
dir_create("graphs/master_seeds")
# Get vertex and edge data from the global graph g_all
vdf_all <- igraph::as_data_frame(g_all, what = "vertices")
edf_all <- igraph::as_data_frame(g_all, what = "edges")
# Nodes for visNetwork (ALL people)
nodes_vis_all <- data.frame(
id    = vdf_all$name,
label = vdf_all$label,
group = vdf_all$group,
title = paste0(
"<b>", vdf_all$label, "</b>",
"<br/>Q-ID: ", vdf_all$name,
"<br/>Seed: ", ifelse(vdf_all$is_seed, "yes", "no")
),
stringsAsFactors = FALSE
)
# Edges for visNetwork (vertical + horizontal)
edges_vis_all <- data.frame(
from   = edf_all$from,
to     = edf_all$to,
title  = edf_all$relation_type,
arrows = ifelse(edf_all$relation_type %in% c("has_father", "has_mother"),
"to", ""),
color  = dplyr::case_when(
edf_all$relation_type %in% c("has_father", "has_mother") ~ "#2c7fb8",  # parents
edf_all$relation_type %in% c("spouse", "spouse_p26")     ~ "#1b9e77",  # spouses
grepl("^sibling", edf_all$relation_type)                 ~ "#7570b3",  # siblings
TRUE                                                     ~ "#aaaaaa"
),
width  = dplyr::case_when(
edf_all$relation_type %in% c("spouse", "spouse_p26") ~ 3,
grepl("^sibling", edf_all$relation_type)            ~ 2.5,
TRUE                                                ~ 1.5
),
smooth = TRUE,
stringsAsFactors = FALSE
)
# Build the big interactive graph
vis_all <- visNetwork(nodes_vis_all, edges_vis_all,
width = "100%", height = "800px") %>%
visOptions(
highlightNearest = TRUE,
nodesIdSelection = list(enabled = TRUE, useLabels = TRUE)
) %>%
visGroups(
groupname = "seed",
color = list(background = "#00b3b3", border = "#008080")
) %>%
visGroups(
groupname = "person",
color = list(background = "#f0f0f0", border = "#bdbdbd")
) %>%
visLegend(
addEdges = data.frame(
label = c("Parent", "Spouse", "Sibling"),
color = c("#2c7fb8", "#1b9e77", "#7570b3")
)
) %>%
visPhysics(
solver = "forceAtlas2Based",
stabilization = FALSE
)
out_file <- "graphs/master_seeds/all_seeds_full.html"
saveWidget(vis_all, file = out_file, selfcontained = TRUE)
cat("Saved global master graph →", out_file, "\n")
